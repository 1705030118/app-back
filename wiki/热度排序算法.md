# hacker news的排名算法
hacker news上面的热度排名多年以来能够很好的反映绝大多数用户的喜好，热度比较高的的文章也不会一直出现在前列，从而导致没有新的内容被关注，   
他们会按照文章的票数多少和发布时间对文章进行一些逻辑处理得到对应的热度排序。  
Score=(P−1)/(T+2)^G
- P:投票数,-1是把自己投的过滤掉
- T:发布到现在的时间间隔,单位小时,+2防止除数太小
- G:重力加速度,它的数值大小决定了排名随时间下降的速度快慢

通俗点的例子  
热度=（浏览量-1）/（发布到现在的时间间隔+2）乖以G的平方 
列表排序由热度决定，热度是由浏览量、作品发布的时间间隔、G值共同决定  
为什么这样好呢？    
能够根据浏览量过滤出同时发布的一批作品集中的热度作品，因为他们的分母相同，而分子大的热度肯定大。    
能够过滤出不同时间段热度高的作品，避免误差  
举例：
```
a在1号发表了作品aa,aa被点击了101次，
b在2号发表了作品bb,bb被点击了51次，在3号比较他们的热度，此处G取2
aa的热度=（101-1）/（48+2）^2 = 0.04
bb的热度=(51-1)/(24+2)^2=0.07
```
这里bb热度>aa热度 ，但是我们会感觉2个其实热度应该一样  
当然，不同情况需要根据实际数据调整好G值，达到最优效果
## 注意点
在其他条件不变的情况下，越是新发表的帖子，排名越高。或者说，一个帖子的排名，会随着时间不断下降。
## 第一个因素是得票数P
在其他条件不变的情况下，得票越多，排名越高。
## 第二个因素是距离发帖时间T
在其他条件不变的情况下，越是新发表的帖子，排名越高。或者说，一个帖子的排名，会随着时间不断下降。
## 第三个因素是重力因子G
> 为什么G=1.5，首先，G是干嘛的。毫无疑问，G这个数字既非时间，也非评价，其实它的主要目的是控制更新频率。G的值越大，score的衰减速度越快，排行的更新越频繁。所以，确定G值需要观察系统内部投票数在时间上的分布，然后根据需要的更新频次确定G的合理取值。越火爆、用户互动越频繁的社区，为了保证排行的稳定性（不要频繁大量的刷新），G值趋向于比较低。这就是为什么Hacker News从一开始的1.8修改成1.5，过段时间可能就变成1.2了。

它的数值大小决定了排名随时间下降的速度。

> 通常来讲，随着时间迁移，热度是需要下降的，不然就会出现马太效应，热者愈热，冷者愈冷。

## 稍作修改
A 为某篇文章的具体发布时间，精确到秒；B 为一个固定的时间常量，2008-12-01 00:00:00。则可以计算得到 A 和 B 间隔的秒数 ts。
ts=A-B  
1）时间点 B，2008-12-01 00:00:00，是一个固定的值。ts 反映了文章的新鲜程度。引入 B 是一个非常优雅的技巧，它使得新鲜度的度量可以独立于系统当前时间。
# Reddit的排名算法
∫(t,y,z)=log10z+yt/4500
- x : 为点赞数与被踩数之差（辅助变量）
- t : 发布时间到现在的时间间隔,单位秒
- z : 作为x和1的绝对值的最大值
- y : x>0 取 1 ， x<0 取 -1 ，x=0 取 0   
举例：
```
86400/45000=1.92 一天权重调整则为1.92
10^1.92 =83 投票差要涨83倍
赞成票加分,投票差前10和接下来的100等权
```
从上图可以看的出来时间是最重要的权重,由于流量比较大,所以对于高赞文章有所优势,适合新闻类排序

### 稍作修改
1）时间点 B，2008-12-01 00:00:00，是一个固定的值。ts 反映了文章的新鲜程度。引入 B 是一个非常优雅的技巧，它使得新鲜度的度量可以独立于系统当前时间。

2）45000 代表的是一个 12.5 小时周期内的总秒数。它 与 ts 一起使用，随着时间的推移，新文章的得分会逐渐超越高投票数的老文章，从而实现自动更新的效果。

3）log10 的使用是另外一个技巧，它可以使得早期的投票获得更大的权重。比如，前 10 票获得的权重，与 11 到 101 票所获得的权重是一样的。

> 最后的建议：我们在设计热度排名算法时，不必拘泥于这六大排名算法，多考虑一下实际业务场景，最主要的是对当前业务的热度有一个比较清晰的定位，这样才能根据实际情况进行算法设计以及相关调整，而不是对着算法照搬照抄。