# 好友动态-Feed流
## 特点
- 读写严重不平衡，读多写少，一般读写比例都在10；1，甚至100：1之上。
## 发布Feed流程
当你发布一条Feed消息的时候，流程是这样的：
1. Feed消息先进入一个队列服务。
2. 先从关注列表中读取到自己的粉丝列表，以及判断自己是否是大V。
3. 将自己的Feed消息写入个人页Timeline（发件箱）。如果是大V，写入流程到此就结束了。
4. 如果是普通用户，还需要将自己的Feed消息写给自己的粉丝，如果有100个粉丝，那么就要写给100个用户，包括Feed内容和Feed ID。
5. 第三步和第四步可以合并在一起，使用BatchWriteRow接口一次性将多行数据写入TableStore。
6. 发布Feed的流程到此结束。

## 读取Feed流流程
当刷新自己的Feed流的时候，流程是这样的：
1. 先去读取自己关注的大V列表
2. 去读取自己的收件箱，只需要一个GetRange读取一个范围即可，范围起始位置是上次读取到的最新Feed的ID，结束位置可以使当前时间，也可以是MAX，建议是MAX值。由于之前使用了主键自增功能，所以这里可以使用GetRange读取。
3. 如果有关注的大V，则再次并发读取每一个大V的发件箱，如果关注了10个大V，那么则需要10次访问。
4. 合并2和3步的结果，然后按时间排序，返回给用户。

至此，使用推拉结合方式的发布，读取Feed流的流程都结束了。
# Hacker News算法
r=(P – 1) / (t + 2)^1.8
- P:投票数,-1是把自己投的过滤掉
- T:发布到现在的时间间隔,单位小时,+2防止除数太小
- G:重力加速度,它的数值大小决定了排名随时间下降的速度快慢

时效性强
- 如何更新score
# Jmeter压力测试
并发量大概在200左右
# 索引优化
# 异步打日志
我们可以将打日志的工作，都抽取出来，做成异步的任务调用，只要需要打日志的地方，我们就将这个任务放到任务线程池里面去，让这个线程池来专门实现异步打日志的功能，这样主流程就完全不用理会存库和打日志等等这些和业务流程毫无关系的事情，专心的做自己该做的事情。

- 线程池参数设置
# ES分词
ES内置了很多分词器，但内置的分词器对中文的处理不好。
- ik的自定义词典

有时，可能ik自身提供的分词词典无法满足特定的一些需求（如专用名词等），ik提供了自定义词典的功能，也就是用户可以自己定义一些词汇,这样ik就会把它们当作词典中的内容来处理。
# Nginx限流,配置优化
# MySQL读写分离
# 推荐功能实现
# TODO
- 基于ELK的日志分析
